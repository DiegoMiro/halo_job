---
title: "Sr. R Shiny Developer"
author: "Diego Miro"
date: today
date-format: long
format:
  revealjs:
    embed-resources: false
    width: 1600
    height: 900
    slide-number: true
    chalkboard: 
      buttons: false
    preview-links: auto
    logo: img/halo_logo.png
    css: ["css/styles.css"]
    footer: "[HALO](https://halopowered.com/)"
project:
  output-dir: docs
editor: visual
---

```{r}
library(tidyverse)
```

```{r}
fun_extract_text <- function(x) {
  x %>%
    rvest::minimal_html() %>%
    rvest::html_text()
}

fun_parse_ul <- function(x) {
  y <- x %>%
    rvest::minimal_html() %>%
    rvest::html_elements(xpath = "//li") %>%
    rvest::html_text()
  
  y <- y %>%
    stringr::str_remove_all("\n")
  
  if (length(y) == 0) y <- NA_character_
  
  return(y)
  
}

fun_starts <- function(
    gt_object, column, max_rating = 5, ..., color = "orange", icon = "star"
) {
  
  stopifnot(
    `Table must be of class 'gt_tbl'` = "gt_tbl" %in% class(gt_object)
  )
  
  gt::text_transform(
    gt_object,
    locations = gt::cells_body(
      columns = {{column}}
    ),
    fn = function(x) {
      num_x <- suppressWarnings(as.numeric(x))
      lapply(
        num_x,
        FUN = function(rating) {
          if (xfun::is_blank(rating) || rating %in% c(NA, "NA", "")) {
            return(gt::html("&nbsp;"))
          }
          rounded_rating <- floor(rating + 0.5)
          stars <- lapply(
            seq_len(max_rating),
            function(i) {
              if (i <= rounded_rating) {
                fontawesome::fa(
                  icon, fill = color, height = "15px", a11y = "sem",
                  prefer_type = "solid"
                )
              }
              else {
                fontawesome::fa(
                  icon, fill = "lightgrey", height = "15px", a11y = "sem"
                )
              }
            }
          )
          label <- sprintf("%s out of %s", rating, max_rating)
          div_out <- htmltools::div(
            title = label,
            `aria-label` = label,
            role = "img", stars,
            style = "padding:0px; width:120px"
            # style = "width:120px"
          )
          
          div_out %>%
            as.character() %>%
            gt::html()
        })
    }) %>%
    gt::cols_align(
      align = "left",
      columns = {{column}}
    )
}
```

```{r}
df_general_stats <- readr::read_csv("data/general_stats.csv")
df_pl <- readr::read_csv("data/pl.csv")
df_shot <- readr::read_csv("data/shot.csv")
df_scoring <- readr::read_csv("data/scoring.csv")
df_scorers <- readr::read_csv("data/scorers.csv")
df_totallds <- readr::read_csv("data/totallds.csv")
df_lds <- readr::read_csv("data/lds.csv")
df_pbp <- readr::read_csv("data/pbp.csv")
df_official <- readr::read_csv("data/official.csv")
```

## About the job

My answers to the job description items

```{r}
url_job <- "https://www.linkedin.com/jobs/view/4315834641"

description_content <- "data/description_content.csv" %>%
  readr::read_csv()

description_content %>%
  gt::gt() %>%
  gt::sub_missing(missing_text = "") %>%
  gt::fmt_markdown(columns = c(text, answer)) %>%
  # gt::fmt_icon(
  #   columns = rating,
  #   fill_color = "orange"
  # ) %>%
  fun_starts(stars, icon = "star") %>%
  gt::cols_width(
    topic    ~ gt::px(100),
    subtopic ~ gt::px(100),
    text     ~ gt::px(300),
    answer   ~ gt::px(100),
    stars    ~ gt::px(150)
  ) %>%
  gt::cols_label(
    topic = "Topic",
    subtopic = "Subtopic",
    text = "Text",
    answer = "Answer",
    stars = "Rating"
  ) %>%
  gt::tab_footnote(
    footnote = gt::md(glue::glue("Processed data from the published [job vacancy]({url_job})")),
    locations = gt::cells_column_labels(columns = c(topic, subtopic, text))
  ) %>%
  gt::tab_footnote(
    footnote = "Self-assessment",
    locations = gt::cells_column_labels(columns = c(answer, stars))
  ) %>%
  gt::tab_options(
    # container.width = "1600px",
    container.height = "700px"
  )
```

## Getting to know the HALO website

The job description directs candidates to visit HALO's website to learn more about the company.

I liked the FIBA World Cup Platform case study and started sketching out a Shiny dashboard.

First, I looked for data sources to feed the dashboard. After some research, I found fibaorganizer.com.

They have software for visualizing match data, which apparently <a href="https://helpdesk.geniussports.com/hc/en-gb/articles/12987757201308-LiveStats-Minimum-and-recommended-PC-specs-for-best-performance" target="_blank">only runs on Windows</a>.

With limited time and a Mac to work on, I decided to go another route. This website also provides an API with FIBA data. But it seemed like too <a href="https://gdap-portal.fiba.basketball/sign-up" target="_blank">much work</a> for just a demo.

My last attempt was to search forums and GitHub to see if anyone had already done something simpler. This <a href="https://github.com/fsmosca/fiba-api" target="_blank">repo</a> has data from the 2023 FIBA World Cup, but it still lacks data variety.

# The Pursuit of data

## Trying to find a data source on the FIBA website

I choose this Brazil <a href="https://www.fiba.basketball/en/history/201-fiba-basketball-world-cup/208182/games/100735-BRA-ESP" target="_blank">game</a>. Ops... I think is better a game that they have <a href="https://www.fiba.basketball/en/history/201-fiba-basketball-world-cup/208182/games/100757-IRI-BRA" target="_blank">won</a>. ðŸ˜…ðŸ˜…ðŸ˜…

After some failed attempts, I found the element that contains the data.

```{r}
#| eval: true
#| echo: true
brazil_match_url <- "https://www.fiba.basketball/en/history/201-fiba-basketball-world-cup/208182/games/100757-IRI-BRA"
brazil_match_html <- xml2::read_html(brazil_match_url)

elements_size <- brazil_match_html %>%
  rvest::html_elements("script") %>%
  as.character() %>%
  stringr::str_length() %>%
  tibble::as_tibble() %>%
  tibble::rowid_to_column() %>%
  dplyr::arrange(desc(value))

brazil_match_data <- brazil_match_html %>%
  rvest::html_elements("script") %>%
  .[elements_size$rowid[1]] %>% # workaround: get the biggest element script
  rvest::html_text() %>%
  stringr::str_remove("self.__next_f.push") %>%
  stringr::str_sub(2, -2) %>%
  jsonlite::fromJSON() %>%
  magrittr::extract2(2) %>%
  stringr::str_sub(4) %>%
  jsonlite::fromJSON()
```

## Data source on the FIBA website

It's an improvement but it still seems like a bad way to get the data.

```{r}
brazil_match_data[[4]] %>%
  listviewer::reactjson(
    collapsed = TRUE,
    width = "1500px",
    height = "700px"
  )
```

## The last chance

Almost giving up, I found this discussion on <a href="https://stackoverflow.com/questions/75281172/scrape-fiba-stats-box-score" target="_blank">stackoverflow</a> with a promising endpoint.

The fibalivestats API have a lot of data. The problem is find a specific match (`match_id` parameter). Maybe this information is in another endpoint. The id used on the www.fiba.basketball doesn't work here.

```{r}
#| eval: false
#| echo: true
fun_get_match_data_api <- function(match_id) {
  
  # 2145647
  
  u <- glue::glue(
    "https://fibalivestats.dcd.shared.geniussports.com/data/{match_id}/data.json"
    )
  
  cat("Try to get data")
  cat("\n")
  cat(u)
  
  u %>%
    httr::GET() %>%
    httr::content("text", encoding = "UTF-8") %>%
    jsonlite::fromJSON()
}
```

## fibalivestats dataset

Using the endpoint of the stackoverflow's discussion I got the data.

```{r}
match_data <- jsonlite::read_json("data/match_2145647.json")
match_data %>%
  listviewer::reactjson(
    collapsed = TRUE,
    width = "1500px",
    height = "700px"
  )
```

## fibalivestats dataset description

And now... structure the data and see what is relevant.

::: {.panel-tabset .nav-pills group="datasets"}
#### Stats

```{r}
df_general_stats %>%
  gtExtras::gt_plt_summary() %>%
  gt::tab_options(
    container.height = "500px"
  )
```

#### PL

```{r}
df_pl %>%
  gtExtras::gt_plt_summary() %>%
  gt::tab_options(
    container.height = "500px"
  )
```

#### Shot

```{r}
df_shot %>%
  gtExtras::gt_plt_summary() %>%
  gt::tab_options(
    container.height = "500px"
  )
```

#### Scoring

```{r}
df_scoring %>%
  gtExtras::gt_plt_summary() %>%
  gt::tab_options(
    container.height = "500px"
  )
```

#### Scorers

```{r}
df_scorers %>%
  gtExtras::gt_plt_summary() %>%
  gt::tab_options(
    container.height = "500px"
  )
```

#### Total LDS

```{r}
df_totallds %>%
  gtExtras::gt_plt_summary() %>%
  gt::tab_options(
    container.height = "500px"
  )
```

#### LDS

```{r}
df_lds %>%
  gtExtras::gt_plt_summary() %>%
  gt::tab_options(
    container.height = "500px"
  )
```

#### PBP

```{r}
df_pbp %>%
  gtExtras::gt_plt_summary() %>%
  gt::tab_options(
    container.height = "500px"
  )
```
:::

# Build a minimal dashboard

With the extracted data, now let's make a simple dashboard.

## Overview (1/4)

![](img/img1.png){fig-align="center"}

## Overview (2/4)

![](img/img2.png){fig-align="center"}

## Overview (3/4)

![](img/img3.png){fig-align="center"}

## Overview (4/4)

![](img/img4.png){fig-align="center"}

## Insights

In the `Points by Time` tab of the dashboard, you can see that GIN lost the game midway through the second half, going a long time without scoring while ROS kept scoring. From that point on, GIN was unable to close the gap. The second-half point difference was 25 points (5 GIN vs. ROS 30). These 25 points were missing from the final score (71 GIN vs. ROS 93).

# Next Steps

## 1) Business and Data Understanding

-   Business Understanding
    -   Learn more about basketball, game metrics, and FIBA
    -   Understand with users what's important to display
    -   Add filters (in first moment not necessary because there's only data from a single game)
-   Data Understanding
    -   Explore other available data
    -   Collect data from more games to understand the differences and avoid being limited to the reality of a single game

## 2) Engineering

-   Data Engineering
    -   Some columns are repetitive, redundant, or appear in more than one data set
    -   Understand the meaning of the data in the leaddata field
    -   Create a database structure to store match data
-   Software Engineering
    -   Exception handling and logs for get, parse, write, and other parts of the flow
    -   Create a login for API access and understand the endpoint structure
-   Dashboard
    -   Optimize performance
    -   Adjust some proportions
    -   Fill empty space and better distribute graphic elements

## 3) Design: create a visual identity

::::: columns
::: {.column width="70%"}
I will take advantage the design work done, using the colors of this image.

Using hierarchical method and clustering variables Red, Green, Blue and Alpha of each color.

```{r}
#| eval: true
#| echo: true
url_image <- "https://framerusercontent.com/images/5C6qdSWkJqTgArbdg5hhP92qE.png"

# read the image
image_theme <- url_image %>%
  imager::load.image()

# extract the color of each pixel
df_image_theme <- image_theme %>%
  as.data.frame() %>%
  tibble::as_tibble() %>%
  tidyr::pivot_wider(
    id_cols = c(x, y),
    names_from = cc,
    values_from = value
  ) %>%
  dplyr::rename(
    "red"   = "1",
    "green" = "2",
    "blue"  = "3",
    "alpha" = "4"
  ) %>%
  dplyr::count(red, green, blue, alpha, sort = TRUE) %>%
  dplyr::mutate(
    p = n / sum(n),
    a = cumsum(p),
    color = grDevices::rgb(red, green, blue, alpha)
  ) %>%
  dplyr::filter(a < 0.95) %>%
  tibble::rowid_to_column()

# prepare data to clustering
df_clust <- df_image_theme %>%
  dplyr::select(red, green, blue, alpha) %>%
  as.data.frame()

rownames(df_clust) <- df_image_theme$color


# hierarchical clustering
hc <- df_clust %>%
  scale() %>%
  dist() %>%
  hclust()
```
:::

::: {.column width="30%"}
![](https://framerusercontent.com/images/5C6qdSWkJqTgArbdg5hhP92qE.png)
:::
:::::

## 3) Design: Dendrogram and color pallete

::::: columns
::: {.column width="70%"}
```{r}
#| eval: true
#| echo: false
#| fig-height: 9
dendrogram_data <- ggdendro::dendro_data(hc)

color_objects <- dendrogram_data$labels$label
names(color_objects) <- dendrogram_data$labels$label


sysfonts::font_add_google("Roboto Mono")
showtext::showtext_auto()

dendrogram_data$segments %>%
  ggplot2::ggplot() +
  ggplot2::geom_segment(ggplot2::aes(x = x, y = y, xend = xend, yend = yend)) +
  ggplot2::geom_label(
    data = dendrogram_data$labels,
    ggplot2::aes(
      x = x,
      y = y,
      label = label,
      hjust = 1,
      fill = label,
      color = ggplot2::after_scale(
        prismatic::best_contrast(fill, c("white", "black"))
      )
    ),
    angle = 0,
    size = 1.5,
    family = "Roboto Mono"
  ) +
  ggplot2::geom_hline(yintercept = 1, linetype = 2) +
  ggplot2::coord_flip() +
  ggplot2::scale_y_continuous(
    breaks = scales::pretty_breaks(),
    expand = ggplot2::expansion(mult = 0.1)
  ) +
  ggplot2::scale_fill_manual(values = color_objects) +
  ggplot2::xlab("Colors") +
  ggplot2::ylab("Distance") +
  ggplot2::ggtitle(
    label = "Hierarchical Clustering of Colors",
    subtitle = gt::md(stringr::str_c("Font: ", url_image))
  ) +
  ggplot2::theme_minimal() +
  ggplot2::theme(
    legend.position = "none",
    axis.text.y = ggplot2::element_blank(),
    panel.grid.minor.y = ggplot2::element_blank(),
    panel.grid.major.y = element_blank()
  )

```
:::

::: {.column width="30%"}
```{r}
#| eval: true
#| echo: false
#| fig-height: 4
#| fig-width: 4
# colors selected
df_color_theme <- hc %>%
  cutree(h = 1) %>%
  tibble::tibble(
    color = names(.),
    cluster = .
  ) %>%
  dplyr::left_join(
    df_image_theme %>%
      dplyr::select(color, n)
  ) %>%
  dplyr::arrange(dplyr::desc(n)) %>%
  dplyr::group_by(cluster) %>%
  dplyr::summarise(color = dplyr::first(color)) %>%
  dplyr::ungroup()


color_theme <- df_color_theme$color
names(color_theme) <- df_color_theme$color

df_color_theme %>%
  ggplot2::ggplot(ggplot2::aes(x = color, y = 1)) +
  ggplot2::geom_col(
    ggplot2::aes(fill = color),
    color = "black"
  ) +
  ggplot2::geom_text(
    ggplot2::aes(
      label = color,
      color = ggplot2::after_scale(
        prismatic::best_contrast(label, c("white", "black"))
      )
    ),
    hjust = 1.2
  ) +
  ggplot2::scale_fill_manual(values = color_theme) +
  ggplot2::coord_flip() +
  ggplot2::theme_void() +
  ggplot2::theme(
    legend.position = "none",
    aspect.ratio = 1
  )
```

A fine adjustment is need to understand why the color [#DD1912FE]{style="color:#DD1912FE"} was distant from the other reds.
:::
:::::

# Thank you
